%!TEX root = main.tex

\section{Probabilistic Inference using Decision Diagrams}\label{sec:parallel}


Bayesian networks represent concise factorizations of a probability distribution by using conditional independence assumptions. The size of the factorization has direct implications toward the cost of reasoning, i.e., probabilitic inference. A more expressive model must be used to further improve a BN's factorization in order to exploit additional independences~\cite{boutilier1996context,friedman1998learning,zhang1996exploiting}. A prominent way of achieving this is by using Boolean algebra to find a more concise and canonical representation, such as a Binary Decision Diagrams (BDD). Compiling a BN into a BDD-like representations is commonly referred to as \emph{knowledge compilation}~\cite{darwiche2002knowledge}, or simply compilation.

\begin{figure}[!t]
    \centering
    \scalebox{0.9}{
        \input{figures/overview.tex}
    }
    \caption{The compositional framework.}
    \label{fig:frameworkoverview}
\end{figure}


Figure~\ref{fig:frameworkoverview} shows an overview of the underlying principles behind probablistic inference using BDDs, divided into two steps: \emph{compilation} and \emph{inference}. We will dive into these steps in the following sections without going into too much detail. In-depth descriptions can be found in~\cite{dal2021compositional}.

\subsection{Compilation}

We first describe compilation as being all steps required to obtain a BDD. In addition to traditional compilation, we introduce partitioning to further improve overall performance~\cite{dal2017reducing}.

A partitioning is found for the BN. This partitioning is optimized by minimizing the sum of each partition's tree-width. Tree-width is a metric commonly used to indicate the complexity of BNs~\cite{bollig2014width}. With the partitioning in hand, the following steps can be performed independently, per partition. Theoretically, compilation is as fast as the slowest compiling partition~\cite{dal2018parallel}. Each partition is considered an independent BN from this point on.

BNs are defined over multi-valued domains. Prior to compiling it to a BDD, we require an encoding to transition from the multi-valued domain to the Boolean domain. There are multiple ways to do this. We chooses to first translate a BN into a satisfiability (SAT) instance in Conjunctive Normal Form (CNF) with dedicated variables to represent probabilities~\cite{chavira2008probabilistic,dal2017wpbdd} (in this step we do not need to introduce extra variables as e.g. a Tseitin transformation would).

The obtained SAT instance serves as an entry point into the field of language compilers~\cite{dudek2020addmc}. These compilers target different variations of BDDs. The process of compiling a SAT instance to a respective BDD using one such compiler is by far the most expensive operation of the entire process. Performance is primarily determined by this step, while inference if mich cheaper.

With monolithic compilation, we would only be able to amortize cost of compilation by performing many inference queries. With partitioned compilation, we shift some of this cost over to the inference side, yielding overall performance improvements in cases where we would traditionally not be able to achieve sufficient amortization~\cite{dal2017reducing}. We have now reached the end of the compilation part as indicated by Figure~\ref{fig:frameworkoverview}.

\subsection{Inference}

After compilation we arrive at the inference step. The upside of getting this far, is that the computational complexity of inference is linear in the size of the target representation~\cite{darwiche2002knowledge}. Inference is performed by traversing the target representation whilst evaluating the underlying arithmetic formula. The arithmetic formula is different for every target representation, but generally we can convert a logical OR to addition, logical AND to multiplication, and substitute variables with the value or probability they represent. All that is left, is to evaluate this formula in order to obtain the marginal probability we seek. In short, this is inference by \emph{Weighted Model Counting} (WMC)~\cite{chavira2008probabilistic}.

In case we chose to partition the BN during the compilation step, we have to compose the compiled BDDs and create a monolithic representation. A partition's representation is connected to another of they share a common variable. This implies that the order in which we traverse partitions is not a total ordering, it is partial. It can be represented by a tree, we suitably refer to as a composition-tree~\cite{dal2021compositional}. The order in which we choose to traverse partitions determines how they are connected. As we traverse one partition, its sink is connected to the next partition's root. Now that all partitions form one connected component, we can proceed as previous described with a traversal we are already familier with from WMC.


\section{\toolname}

\begin{figure}[!t]
    \centering
    \input{figures/implementation.tex}
    \caption{The implementation.}
    \label{fig:implementation}
\end{figure}


%Figure~\ref{fig:frameworkoverview} shows a high level overview of the tool's internal processes.
%
%A partitioning is found for the BN. This partitioning is optimized by minimizing the sum of each partition's tree-width. Tree-width is a metric commonly use to indicate the complexity of BNs~\cite{bollig2014width}.
%
% using \emph{simulated annealing}
%
%
% The \toolname compiler however specifically targets \emph{Weighted Positive Binary Decision Diagrams} (WPBDD), which is a dedicated representation for probabilistic inference. (We discuss differences with other representations in Section~\ref{sec:conclusion}.) In addition, the compiler introduces a partitioning to further improve overall performance~\cite{dal2017reducing}.
%
%
%\toolname takes this Boolean formula and compiles it to a WPBDD.          , yielding a WPBDD per partition
%
%
%is that the computational complexity of inference is linear in the size of the target representation~\cite{darwiche2002knowledge}, in our case a WPBDD.
%
%
%
%With the partitioning in hand, the following steps can be performed in parallel, per partition. Theoretically, compilation is as fast as the slowest compiling partition~\cite{dal2018parallel}.
%


